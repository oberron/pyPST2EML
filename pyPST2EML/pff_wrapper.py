"""
Call this after having run the pffexport_test1.sh

```bash
pffexport /mnt/e/2021Q2_mmWave.pst -f all -t /mnt/e/2021Q2_mmWave_new2
```

"""

# STANDARD MODULES

import re
from os.path import abspath, exists, isfile, join, splitext
from os import makedirs, walk

## Import smtplib for the actual sending function
import smtplib
## For guessing MIME type based on file name extension
import mimetypes


## Import the email modules we'll need
from email.message import EmailMessage
from email.utils import formataddr
from email import message_from_file

#PIP modules
from tqdm import tqdm

# local modles
from pst2eml import change_creation_date, rename_eml

#TODO: add handler for multiple TO: display name email addresses
#TODO: add handler for ti address formatting
#TODO: add handler for CC names
#TODO: check ppt and pdf attachemnts can be opened
#TODO: add file naming / properties handling

outlook_export_dir = "E:\\2021Q2_mmWave_new2.export\\Top of Outlook data file\\"

class Gen_Emails(object):
    """ Wrapper class to parse folder structure generated by pff and 
    Generates a folder structure of .eml files formatted 
    with filename, authors and creation date matching email properties """ 

    def __init__(self,folder_path,debug=False):
        self.folder_path = folder_path
        #list of cid used in html email
        self.cids =[]
        # list of To: addresse
        self.tos = []
        self.ccs = []
        self.bccs = []
        self.email_properties = { "Sender name:":"",\
                "Sender email address:":"",\
                "Conversation topic:":"",\
                "Display name:":"",\
                "Recipient display name:":"",\
                "Delivery time:":"",\
                "Date:":""}
        self.body_html=None
        self.debug = debug


    def clean_email_address(self,email):
        #TI email formatting
        if email[:6].lower()=="/o=ti/":
            email = email.lower().split("/cn=")[-1]+"@ti.com"
        return email

    def parse_recipients(self):
        """ Parse Recipients.txt to extract key information need to create the .eml file """
        try:
            with open(join(self.folder_path,"Recipients.txt"),'r',encoding="utf-8") as fi:
                    txt_file = fi.read()
            dn,email,to_cc_bcc = None, None, None
            for line in txt_file.split("\n"):
                prop = "Display name:"
                if line.find(prop)>=0:
                    dn = line.split(prop)[1].strip()
                prop = "Email address:"
                if line.find(prop)>=0:
                    email = line.split(prop)[1].strip()
                    email = self.clean_email_address(email)
                prop = "Recipient type:"
                if line.find(prop)>=0:
                    to_cc_bcc=line.split(prop)[1].strip()
                    if to_cc_bcc=="To":
                        self.tos.append((dn,email))
                    elif to_cc_bcc=="CC":
                        self.ccs.append((dn,email))
                    elif to_cc_bcc=="BCC":
                        self.bccs.append((dn,email))
                    else:
                        raise Exception(f"unknown property in Recipients.txt: {self.folder_path} - {to_cc_bcc}")
                    dn,email,to_cc_bcc = None, None, None
        except FileNotFoundError:
            self.tos.append(("Undisclosed recipients:",""))
        except:
            raise
    def parse_txt_files(self):
        for file in ["OutlookHeaders.txt","InternetHeaders.txt" ]:
            with open(join(self.folder_path,file),'r',encoding="utf-8") as fi:
                txt_file = fi.read()
            for line in txt_file.split("\n"):
                for prop in self.email_properties:
                    if line.find(prop)>=0:
                        email_prop = line.split(prop)[1].strip()
                        if prop == "Sender email address:":
                            email_prop = self.clean_email_address(email_prop)
                        self.email_properties[prop] = email_prop

    def get_alternate_body(self):
        """ Parses .html or .rtf file to add as alternate body for the email
        .html has 2 pass one for encoding, second to copy content"""
        html_body_fp = join(self.folder_path,"Message.html")
        rtf_body_fp = join(self.folder_path,"Message.rtf")
        if exists(html_body_fp):
            encoding = []
            try:
                with open(html_body_fp,'r',errors='ignore') as fi:
                    body_html = fi.read()
                #examples of charset strings found:
                #<meta http-equiv=Content-Type content="text/html; charset=
                #<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
                #encoding = re.findall(r"<meta http-equiv=content-type content=\"text/html; charset=([a-zA-Z0-9.@-]*)\"", body_html.lower())
                encoding = re.findall(r"charset=([a-zA-Z0-9.@-]*)\"", body_html.lower())
            except:
                print(f"********* failed to open {self.folder_path},Message.html")
                raise
            if self.debug:
                print("encoding",encoding)
            if not encoding:
                encoding = "utf-8"
            else:
                encoding = encoding[0]

            try:
                #note the errors="ignore" should not be needed but there seem to be limitations on the python
                #reading of gb2312 and adding the ignore, avoids crashing.
                #FIXME: need to find a way to log / add specific hooks here
                with open(html_body_fp,'r',encoding=encoding,errors="ignore") as fi:
                    self.body_html = fi.read()
                    self.body_rtf = ""
            except:
                print(f"********* failed to open {self.folder_path},Message.html, with encoding {encoding}")
                raise
        elif exists(rtf_body_fp):
            try:
                with open(join(self.folder_path,"Message.rtf"),'r',encoding="latin-1") as fi:
                    self.body_rtf = fi.read()
                    self.body_html = ""
            except:
                print(f"********* failed to open {self.folder_path},Message.html")
                raise
        else:
            self.body_rtf = ""
            self.body_html = ""

        
        
    def add_cid(self):
        """
        add images to the email when references as cid in teh html body
        id="Picture_x0020_1" src="cid:image001.png@01D76DA8.268FA380" alt="Description: camea"
        """
        
        cids = re.findall(r"src=\"cid:([a-zA-Z0-9.@]*)\"", self.body_html)

        for i, cid in enumerate(cids):
            img_fn_indexed = f"{i+1}_"+cid.split("@")[0]
            img_fp_i = join(self.folder_path ,"Attachments",img_fn_indexed)
            img_fn = cid.split("@")[0]
            img_fp = join(self.folder_path ,"Attachments",img_fn)
            if exists(img_fp_i):
                with open(img_fp_i, 'rb') as img:
                    self.msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',
                                             cid=cid)
                self.cids.append(img_fp_i)
            elif exists(img_fp):
                with open(img_fp, 'rb') as img:
                    self.msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',
                                             cid=cid)
                self.cids.append(img_fp)
            else:
                found = False
                for fp in []:
                    for ext in ["jpeg","jpg","png","gif"]:
                        if fp.find(ext):
                            found = True
                            break
                if found:
                    print(f"cannot find {img_fp_i} or {img_fp}")
                    raise Exception(f"could not load cid {cid} for {self.folder_path}")
                else:
                    if self.debug:
                        print(149, self.cids)

            
            
    def make_email(self):
        msg = EmailMessage()
        self.parse_txt_files()
        self.get_alternate_body()
        with open(join(self.folder_path,"Message.txt"),'r',encoding="utf-8") as fi:
            body_txt = fi.read()

        msg.set_content(body_txt)
        if self.body_html:
            msg.add_alternative(self.body_html,subtype='html')
        elif self.body_rtf:
            msg.add_alternative(self.body_rtf,subtype='rtf')
        
        msg['From'] = formataddr((self.email_properties["Sender name:"],\
                        self.email_properties["Sender email address:"]))
        #FIXME: need to make list comprehension here
        #msg['To'] = formataddr((self.email_properties["Recipient display name:"], 'jack@example.org'))
        self.parse_recipients()
        #print(94,",".join(self.tos))
        tos = []
        for dn_em in self.tos:
            top = formataddr(dn_em)
            tos.append(top)
        tos = ", ".join(tos)
        msg['To'] = tos #(formataddr(dn,email) for (dn,email) in self.tos)
        msg["Date"] = self.email_properties["Date:"]
        ccs = []
        for dn_em in self.ccs:
            cc = formataddr(dn_em)
            ccs.append(cc)
        ccs = ", ".join(ccs)
        msg['CC'] = ccs
        msg["Subject"] = self.email_properties["Conversation topic:"]
        self.msg = msg
        if self.body_html:
            self.add_cid()
        self.add_folder_attachments()


    def add_folder_attachments(self):
        #add files found in Attachments which are note used as cid
        for _, _, files in walk(join(self.folder_path,"Attachments")):
            for fn in files:
                file = join(self.folder_path,"Attachments",fn)
                if not isfile(file):
                    continue
                if file in self.cids:
                    continue
                # Guess the content type based on the file's extension.  Encoding
                # will be ignored, although we should check for simple things like
                # gzip'd or compressed files.

                ctype, encoding = mimetypes.guess_type(file)
                if ctype is None or encoding is not None:
                    # No guess could be made, or the file is encoded (compressed), so
                    # use a generic bag-of-bits type.
                    ctype = 'application/octet-stream'
                maintype, subtype = ctype.split('/', 1)
                with open(file, 'rb') as fp:
                    self.msg.add_attachment(fp.read(),
                                       maintype=maintype,
                                       subtype=subtype,
                                       filename=fn)
    def save_file(self,folder_path):
        """ save email to file with 
        filename a close string to the subject string
        author being teh sender
        creation date being the date the email was sent
        """
        if self.debug:
            print(f"saving to:{folder_path}")
        temp_fp = join(folder_path,"temp.eml")
        #fp = join(folder_path,self.fn)
        with open(temp_fp, 'wb') as fo:
            fo.write(bytes(self.msg))
        fn = rename_eml(temp_fp,self.email_properties["Conversation topic:"])
        change_creation_date(fn,self.email_properties["Delivery time:"])
        return fn


def run():
    count = 0
    max_count = -1
    for root,folders,files in walk(outlook_export_dir):
        for folder in tqdm(folders,total=len(folders)):
            
            if count>max_count and max_count>-1:
                exit()
            #if count in [1,10,20,50,70,100]:
            #    print(count, len(folders), folder, max_count)
            if folder.find("Message")==0:
                count+=1
                
                mel = Gen_Emails(join(root,folder))
                mel.make_email()
                dest_folder = abspath(join(root.replace("gitw\\pyPST2EML\\2021Q2_mmWave_test1.export\\Top of Outlook data file\\","2021Q2_mmWave_new\\")))
                if not exists(dest_folder):
                    makedirs(dest_folder)
                mel.save_file(dest_folder)
                mel = None

def ftp_refresh_dirs(root):
   for r, d, files in walk(root):
      for f in files:
         ftp_refresh_fp(join(r,f))

def ftp_refresh_fp(fp):
    ext = splitext(fp)[1]
    print(fp, ext)
    #for file in tqdm(files,total=len(files)):
    index=0
    if ext==".eml":
        index+=1
    print(index)
    if index>10:
        exit()
    if exists(fp):
        print(fp)
        with open(fp,encoding="utf-8") as fi:
            mail = message_from_file(fi)
        sent = mail['Date']
        if sent is None:
            print(f"CHANGING Date header: {sent}")
            #mail["Date"]="Wed, 23 Jun 2021 06:00:02"
            #with open(fp.replace(".eml","_temp.eml"), 'wb') as fo:
            #    fo.write(bytes(mail))
        else:
            print(f"OOOOKKKK Date header: {sent}")
            change_creation_date(fp,mail['Date'])

    else:
       print("KOOOOOOOOOOOOO",join(root,file))
    #change_creation_date

def debug():
    message_folder = join(outlook_export_dir,"D2D-Inbox","Message00683")
    mel = Gen_Emails(message_folder,debug=True)
    mel.make_email()
    fp = mel.save_file("")
    print(fp)
    ftp_refresh_fp(fp)

if __name__=="__main__":
    root = "./"
    fn= "Meeting with Globe and TI on IWR6843AOP Lawn Mower Project[7]_temp.eml"
    ftp_refresh_dirs("C:\\outlook\\archives\\eml\\2021Q2_mmWave_temp2")
    #debug()
    run()

